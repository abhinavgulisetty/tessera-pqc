"""
Simplified Kyber-like Key Encapsulation Mechanism (KEM).

This is a pedagogical implementation of a Module-LWE KEM inspired by
CRYSTALS-Kyber (NIST PQC winner).  Parameter set: k=2, n=256, q=3329, η=2.

Security note: NOT production-ready. No constant-time guarantees.
For research / simulation only.
"""
from __future__ import annotations

import os
import hashlib
from typing import Tuple

import numpy as np
from .math import PolynomialRing

K   = 2
N   = 256
Q   = 3329
ETA = 2

DU  = 10
DV  = 4


def _pack_bits(values: np.ndarray, bits: int) -> bytes:
    """Pack integer array into a byte string, *bits* bits per element (LSB first)."""
    out = bytearray()
    buf, filled = 0, 0
    mask = (1 << bits) - 1
    for val in values:
        buf |= (int(val) & mask) << filled
        filled += bits
        while filled >= 8:
            out.append(buf & 0xFF)
            buf >>= 8
            filled -= 8
    if filled:
        out.append(buf & 0xFF)
    return bytes(out)


def _unpack_bits(data: bytes, bits: int, count: int) -> np.ndarray:
    """Unpack *count* values of *bits* bits each from *data* (LSB-first packing)."""
    mask = (1 << bits) - 1
    result = []
    buf, filled = 0, 0
    for byte in data:
        buf |= byte << filled
        filled += 8
        while filled >= bits and len(result) < count:
            result.append(buf & mask)
            buf >>= bits
            filled -= bits
    return np.array(result[:count], dtype=np.int64)


def _poly_to_bytes(poly: np.ndarray, bits: int) -> bytes:
    """Compress poly coefficients to *bits* bits each (lossy for bits < 12)."""
    n = len(poly)
    compressed = np.round(
        poly.astype(np.float64) * (1 << bits) / Q
    ).astype(np.int64) % (1 << bits)
    return _pack_bits(compressed, bits)


def _bytes_to_poly(data: bytes, bits: int, n: int = N) -> np.ndarray:
    """Decompress *data* back into poly coefficients in Z_Q."""
    compressed = _unpack_bits(data, bits, n)
    return np.round(
        compressed.astype(np.float64) * Q / (1 << bits)
    ).astype(np.int64) % Q


_SK_BITS = 12


def _pack_sk(polyvec: list[np.ndarray]) -> bytes:
    """Losslessly pack a polynomial vector as the secret key (no compression)."""
    out = bytearray()
    for p in polyvec:
        out += _pack_bits(p, _SK_BITS)
    return bytes(out)


def _unpack_sk(data: bytes, k: int = K) -> list[np.ndarray]:
    """Unpack a losslessly-stored secret-key polynomial vector."""
    chunk = (N * _SK_BITS + 7) // 8
    return [_unpack_bits(data[i * chunk:(i + 1) * chunk], _SK_BITS, N) for i in range(k)]


def _pack_polyvec(polyvec: list[np.ndarray]) -> bytes:
    """Pack a vector of k polynomials using DU-bit compression (for ciphertext u)."""
    return b"".join(_poly_to_bytes(p, DU) for p in polyvec)


def _unpack_polyvec(data: bytes, k: int = K) -> list[np.ndarray]:
    """Unpack a vector of k polynomials from DU-bit compressed bytes."""
    chunk = len(data) // k
    return [_bytes_to_poly(data[i * chunk:(i + 1) * chunk], DU) for i in range(k)]


def _cbd(eta: int = ETA) -> np.ndarray:
    """
    Sample a polynomial with each coefficient drawn from CBD(η).

    CBD(η) is implemented by summing η pairs of random bits:
        x = Σ_{i=0}^{η-1} (aᵢ - bᵢ),   aᵢ,bᵢ ∈ {0,1}   → x ∈ {-η,...,η}
    """
    num_bytes = (2 * eta * N + 7) // 8
    raw = np.frombuffer(os.urandom(num_bytes), dtype=np.uint8)
    bits = np.unpackbits(raw)[:2 * eta * N].reshape(N, 2 * eta)
    a = bits[:, :eta].sum(axis=1).astype(np.int64)
    b = bits[:, eta:].sum(axis=1).astype(np.int64)
    return (a - b) % Q


def _expand_a(seed: bytes, k: int = K) -> list[list[np.ndarray]]:
    """
    Expand seed into a k×k matrix A of polynomials (each in Z_Q^N).

    Mirrors Kyber's Gen: each A[i][j] is generated by SHAKE-128(seed || i || j).
    Coefficients are drawn by rejection-sampling until N valid ones found.
    """
    A = [[None] * k for _ in range(k)]
    for i in range(k):
        for j in range(k):
            shake = hashlib.shake_128(seed + bytes([i, j]))
            coeffs = []
            while len(coeffs) < N:
                block = shake.digest(N * 3)
                for pos in range(0, len(block) - 1, 3):
                    d1 = block[pos]     | ((block[pos + 1] & 0x0F) << 8)
                    d2 = (block[pos + 1] >> 4) | (block[pos + 2] << 4)
                    if d1 < Q:
                        coeffs.append(d1)
                    if d2 < Q and len(coeffs) < N:
                        coeffs.append(d2)
                    if len(coeffs) < N:
                        shake = hashlib.shake_128(seed + bytes([i, j]) + bytes(len(coeffs)))
            A[i][j] = np.array(coeffs[:N], dtype=np.int64)
    return A


def _matvec_mul(ring: PolynomialRing, A: list[list[np.ndarray]],
                s: list[np.ndarray]) -> list[np.ndarray]:
    """Compute A·s in the NTT domain.  Returns a k-vector of polynomials."""
    k = len(A)
    result = []
    s_ntt = [ring.ntt(si) for si in s]
    for i in range(k):
        acc = np.zeros(N, dtype=np.int64)
        for j in range(k):
            acc = (acc + ring.point_mul(ring.ntt(A[i][j]), s_ntt[j])) % ring.q
        result.append(ring.inv_ntt(acc))
    return result


def _vec_inner(ring: PolynomialRing,
               u: list[np.ndarray], v: list[np.ndarray]) -> np.ndarray:
    """Inner product of two poly-vectors: Σ uᵢ·vᵢ  (NTT-based)."""
    acc = np.zeros(N, dtype=np.int64)
    for ui, vi in zip(u, v):
        acc = (acc + ring.point_mul(ring.ntt(ui), ring.ntt(vi))) % ring.q
    return ring.inv_ntt(acc)


class LatticeKEM:
    """
    Simplified Module-LWE Key Encapsulation Mechanism (Baby Kyber).

    Parameter set: k=2, n=256, q=3329, η=2.

    API:
        pk, sk = kem.keygen()
        ct, ss = kem.encaps(pk)
        ss2    = kem.decaps(sk, ct)
        assert ss == ss2   # shared secret recovered!
    """

    def __init__(self, ring: PolynomialRing | None = None):
        self.ring = ring or PolynomialRing()
        self.k    = K
        self.n    = N
        self.q    = Q
        self.eta  = ETA


    def keygen(self) -> Tuple[bytes, bytes]:
        """
        Generate a (public key, secret key) pair.

        Algorithm:
          1. Draw a random 32-byte seed.
          2. Expand seed → public matrix A ∈ R_q^{k×k}.
          3. Sample secret s ∈ R_q^k  and noise e ∈ R_q^k  using CBD(η).
          4. Compute public key b = A·s + e  (all mod q).
          5. Serialise: pk = (seed, b),  sk = s.

        Returns:
            pk: Public key bytes.
            sk: Secret key bytes.
        """
        rng = self.ring
        seed = os.urandom(32)
        A    = _expand_a(seed, self.k)

        s = [_cbd(self.eta) for _ in range(self.k)]
        e = [_cbd(self.eta) for _ in range(self.k)]

        As = _matvec_mul(rng, A, s)
        b  = [(As[i] + e[i]) % self.q for i in range(self.k)]

        pk = seed + _pack_polyvec(b)
        sk = _pack_sk(s)
        return pk, sk


    def encaps(self, pk: bytes) -> Tuple[bytes, bytes]:
        """
        Encapsulate: generate a shared secret and a ciphertext.

        Algorithm:
          1. Decode pk → (seed, b).
          2. Re-expand A from seed.
          3. Sample ephemeral vectors r, e₁, e₂  using CBD(η).
          4. Compute:  u = Aᵀ·r + e₁     (first component of ciphertext)
                       v = bᵀ·r + e₂ + ⌈q/2⌉·m   (second component)
          5. Generate shared secret ss = SHA3-256(m).
          6. Return ciphertext (u, v) and ss.

        Args:
            pk: Public key from keygen().
        Returns:
            (ciphertext_bytes, shared_secret_bytes)
        """
        rng  = self.ring
        seed = pk[:32]
        b    = _unpack_polyvec(pk[32:], self.k)
        A    = _expand_a(seed, self.k)

        r  = [_cbd(self.eta) for _ in range(self.k)]
        e1 = [_cbd(self.eta) for _ in range(self.k)]
        e2 = _cbd(self.eta)

        m_bytes = os.urandom(32)
        m_bits  = np.unpackbits(np.frombuffer(m_bytes, dtype=np.uint8))[:N].astype(np.int64)
        msg_poly = m_bits * ((self.q + 1) // 2)

        A_T = [[A[j][i] for j in range(self.k)] for i in range(self.k)]
        At_r = _matvec_mul(rng, A_T, r)
        u = [(At_r[i] + e1[i]) % self.q for i in range(self.k)]

        bt_r = _vec_inner(rng, b, r)
        v    = (bt_r + e2 + msg_poly) % self.q

        ss = hashlib.sha3_256(m_bytes).digest()

        ct = _pack_polyvec(u) + _poly_to_bytes(v, DV)
        return ct, ss


    def decaps(self, sk: bytes, ct: bytes) -> bytes:
        """
        Decapsulate ciphertext *ct* using secret key *sk*.

        Algorithm:
          1. Decode sk → s,  ct → (u, v).
          2. Compute:  m' = v - sᵀ·u   (mod q)
          3. Decode m' by rounding coefficients to nearest {0, q/2}.
          4. Derive shared secret ss = SHA3-256(m'_bytes).

        Args:
            sk: Secret key from keygen().
            ct: Ciphertext from encaps().
        Returns:
            Shared secret bytes (32 bytes).
        """
        rng = self.ring

        s = _unpack_sk(sk, self.k)

        u_bytes_len = len(ct) - len(_poly_to_bytes(np.zeros(N, dtype=np.int64), DV))
        u = _unpack_polyvec(ct[:u_bytes_len], self.k)
        v = _bytes_to_poly(ct[u_bytes_len:], DV)

        st_u = _vec_inner(rng, s, u)
        m_raw = (v - st_u) % self.q

        m_bits = (
            np.round(m_raw.astype(np.float64) * 2.0 / self.q)
            .astype(np.int64) % 2
        ).astype(np.uint8)

        m_bytes  = np.packbits(m_bits[:N]).tobytes()[:32]

        return hashlib.sha3_256(m_bytes).digest()
